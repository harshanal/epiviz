% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/epi_map_leaflet.R
\name{epi_map_leaflet}
\alias{epi_map_leaflet}
\title{epi_map_leaflet}
\usage{
epi_map_leaflet(
  dynamic = FALSE,
  df,
  value_col,
  data_areacode = NULL,
  inc_shp = TRUE,
  shp_filepath = NULL,
  shp_areacode = NULL,
  fill_palette = "Blues",
  fill_opacity = 1,
  break_intervals = NULL,
  break_labels = NULL,
  force_cat = TRUE,
  n_breaks = NULL,
  labels = NULL,
  map_title = "",
  map_title_size = 13,
  map_title_colour = "#007C91",
  map_footer = "",
  map_footer_size = 12,
  map_footer_colour = "#007C91",
  area_labels = FALSE,
  area_labels_topn = NULL,
  legend_title = "",
  legend_pos = "topright",
  map_zoom = NULL,
  border_shape_filepath = NULL,
  border_code_col = NULL,
  border_areaname = NULL
)
}
\arguments{
\item{dynamic}{Logical indicating whether to produce a dynamic (leaflet) output.
Default is \code{FALSE}, which will return a static ggplot output.}

\item{df}{Data frame containing values used to fill areas on the output map.
Can include pre-merged shapefile data if inc_shp = TRUE.}

\item{value_col}{Name of the variable in df used to fill map areas.}

\item{data_areacode}{Name of the variable in df containing the name or code of
the map areas to be plotted. (Mandatory if shp_filepath argument passed).}

\item{inc_shp}{boolean parameter to indicate whether df already includes shapefile
data.}

\item{shp_filepath}{filepath for the shapefile containing the spatial information
for the resultant map output. This will not be used if inc_shp = TRUE.}

\item{shp_areacode}{Name of the variable in shp_filepath containing the name
or code of the map areas to be plotted. (Mandatory if shp_filepath argument passed).}

\item{fill_palette}{name of the RColorBrewer palette to use in map fill (default = "Blues")}

\item{fill_opacity}{numeric value between 0 and 1 to determine map fill-color opacity.}

\item{break_intervals}{numeric vector of interval points for legend
(Mandatory if break_labels argument is passed, break_intervals and break_labels must be
of equal length).}

\item{break_labels}{vector of labels to include in the legend.
(Mandatory if break_labels argument is passed, break_intervals and break_labels must be
of equal length).}

\item{force_cat}{boolean parameter to determine whether all arguments passed
in break_labels are used in the legend, even if there are no values present in the data.}

\item{n_breaks}{Number of break intervals. This argument is an alternative
to supplying defined breaks via break_labels, and will provide a number of
evenly distributed breaks as specified (default = 5). If break_labels argument is passed,
n_breaks will be ignored.}

\item{labels}{name of string variable in df containing labels for each map area. If
dynamic = FALSE, these labels will be positioned in the centre of each map area.
If dynamic = TRUE, then these labels will appear as hover-over labels. If dynamic =
TRUE, labels can include HTML.}

\item{map_title}{string to determine map title.}

\item{map_title_size}{font size of map title.}

\item{map_title_colour}{string to determine map title colour.}

\item{map_footer}{string to determine map footer.}

\item{map_footer_size}{font size of map footer.}

\item{map_footer_colour}{string to determine map title colour.}

\item{area_labels}{boolean parameter to add data_areacode as static area labels to the
map areas. If dynamic = FALSE and a labels parameter has alredy been supplied, then area_labels
will be ignored.}

\item{area_labels_topn}{numeric value to display only area_labels for areas with
the top n values of value_col (e.g. if area_labels_topn = 5, only area_labels for map
areas with the top 5 values of value_col will be displayed).}

\item{legend_title}{string to determine legend title.}

\item{legend_pos}{string to determine legend position. When dynamic = TRUE, both
ggplot and leaflet permissable legend positions can be provided. When dynamic = FALSE,
only leaflet permissable legend positions can be provided (i.e."topright", "bottomright",
"bottomleft", or "topleft").}

\item{map_zoom}{A single row data frame with variables of 'LAT', 'LONG', and 'zoom'
that allows the map to be zoomed in on a specific region (e.g. data.frame(LONG =
-2.547855, LAT = 53.00366, zoom = 6)). LAT = numerical latitude coordinate for
the centre point of the zoom, LONG = numerical longitude coordinate for the
centre point of the zoom, zoom = numerical value to represent the depth of zoom.}

\item{border_shape_filepath}{Optional filepath for a shapefile containing additional
borders to include in the output map. This should be a higher geography than the base
map (e.g. if creating a map displaying UTLAs, a shapefile containing regional boundaries
or higher should be used). Only boundaries contained within border_shape_filepath will
be used, areas will be unfilled.}

\item{border_code_col}{Variable name of the area code / name within border_shape_filepath.
Required if a specific area within the border shapefile is required.}

\item{border_areaname}{String containing the name of a specific area within
border_code_col to be plotted. If supplied, only the boundaries of border_areaname will
be plotted. If not supplied, the boundaries of all areas within border_shape_filepath
will be plotted.}
}
\value{
A ggplot or leaflet object.
}
\description{
A function to produce either static (ggplot) or dynamic (leaflet)
choropleth maps.
}
